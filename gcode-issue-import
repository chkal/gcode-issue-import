#!/usr/bin/perl
use strict;
use warnings;
use 5.8.0;
use Net::Google::Code '0.19';
use Net::GitHub '0.21';
use Getopt::Long;
use Pod::Usage;

=head1 NAME

gcode-issue-import - Import issues from Google Code into Github's issue tracker

=head1 SYNOPSIS

    gcode-issue-import \
        --from your_googlecode_projectname \
        --to   owner/githubreponame

=head1 DESCRIPTION

This script aims to pull as much data as possible from Google Code's issue
tracker and insert it into Github's issue tracker.

This should be considered ALPHA-QUALITY CODE .  Do not (yet) run it targeting a
Github issue tracker that contains data you care about, or you may spend days
manually deleting ugly tickets.

=head1 OPTIONS

=over 4

=item --from <google code project name>

The project name of your Google Code project.  Mandatory.

=item --to <github user/repository>

The target Github repository, in user/repositoryname format.  Mandatory.

=item --github-login <username>

Your Github login name.  Optional.  If not provided, value will be pulled from
your git configuration with `git config`

=item --github-token <api token>

Your Github API token.  Optional.  If not provided, value will be pulled from
your git configuration with `git config`

=item --help

Short-form help

=item --man

Full manpage

=back

=head1 SEE ALSO

=over 4

=item * 

google-code-to-github-issues.pl by Tatsuhiko Miyagawa
(L<http://remediecode.org/2009/04/moved-issues-to-github.html>), which was the basis for this script

=item *

L<App::SD|App::SD>, which purports to do bidirectional replication of issues
between various bugtrackers, including Google Code and Github.  It didn't work
for me, however.

=back

=head1 AUTHORS

Dave O'Neill <dmo@dmo.ca>

Based on google-code-to-github-issues.pl by Tatsuhiko Miyagawa
(L<http://remediecode.org/2009/04/moved-issues-to-github.html>)

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

our $VERSION = '0.100';

my($gc_proj, $gh_proj);
my %github;
GetOptions(
	'from=s'         => \$gc_proj,
	'to=s'           => \$gh_proj,
	'github-login=s' => \$github{'login'},
	'github-token=s' => \$github{'token'},
	'help'           => sub { pod2usage( -exitval => 0, -verbose => 1 ) },
	'man'            => sub { pod2usage( -exitval => 0, -verbose => 2 ) },
) || pod2usage( -exitval => 1, -verbose => 0 );

if( !$gc_proj ) {
	pod2usage( -message => 'You must specify a Google Code project with --from');
}

if( !$gh_proj || $gh_proj !~ m{^[^/]+/[^/]+$}) {
	pod2usage( -message => 'You must specify a valid-looking Github repository with --to');
}

@github{qw( owner repo )} = split '/', $gh_proj;

chomp($github{login} = `git config github.user`)  unless $github{login};
chomp($github{token} = `git config github.token`) unless $github{token};

my $code = Net::Google::Code->new(project => $gc_proj);
my $github = Net::GitHub->new(%github);

my @gcode_closed_statii = qw(
	Fixed
	Verified
	Invalid
	Duplicate
	WontFix
);

for my $issue ( $code->issue->list() ) {

	$issue->load_comments();

	import_issue( $github->issue, $issue );

	# Ensure we don't blow Github's 60 requests per minute API limit.
	sleep (2);
}

sub import_issue
{
	my ($gi, $issue) = @_;

	my $desc_with_user =
		"Originally filed by " . $issue->reporter . " on " . $issue->reported
		. "\n\n"
		. $issue->description();

	my $gh_issue = $gi->open($issue->summary, $desc_with_user);

	if( ! $gh_issue->{number} ) {
		# Probably an error
		if( exists $gh_issue->{error} ) {
			die "Net::GitHub aborted ticket creation with error: $gh_issue->{error}";
		}
		die "Net::GitHub didn't successfully create a ticket for some unknown reason, instead returning $gh_issue";
	}

	print 'Google Code issue '
		. $issue->id
		. ' (' . $issue->summary
		. ') created as Github issue '
		. $gh_issue->{number}
		. "\n";

	# Labels
	foreach my $label ( @{ $issue->labels } ) {
		$gi->add_label( $gh_issue->{number}, $label );
	}

	# Comments
	$issue->load_comments();
	foreach my $comment (@{ $issue->comments }) {

		my @update_info = ();

		if( $comment->updates ) {

			# Can't handle change in ownership via Net::GitHub
			if (exists $comment->updates->{owner} ) {
				my $o = delete $comment->updates->{owner};
				push(@update_info, "Original ticket set owner to $o");
			}

			if (exists $comment->updates->{labels} ) {
				my $l = delete $comment->updates->{labels};
				foreach ( @{ $l } ) {
					if( s/^-// ) {
						$gi->remove_label( $gh_issue->{number}, $_);
						push(@update_info, "Removed label $_");
					} else {
						$gi->add_label( $gh_issue->{number}, $_);
						push(@update_info, "Added label $_");
					}
				}
			}

			if( exists $comment->updates->{status} ) {
				my $s = delete $comment->updates->{status};
				update_status( $gi, $gh_issue, $s );
				push(@update_info, "Original ticket set status to $s (we converted to $gh_issue->{state})");
			}

			if( exists $comment->updates->{summary} ) {
				my $s = delete $comment->updates->{summary};
				$gi->edit( $gh_issue->{number},
					$s,
					$gh_issue->{body});
				push(@update_info, "Summary changed from '$gh_issue->{summary}' to '$s'");
				$gh_issue->{summary} = $s;
			}

			# Warn of missed updates
			foreach my $unhandled (keys %{$comment->updates}) {
				warn "Didn't handle update key $unhandled";
			}
		}

		next unless ($comment->content || scalar @update_info);

		my $comment_with_user =
			"Updated by "
			. $comment->author
			. " on "
			. $comment->date;

		if( $comment->content ) {
			$comment_with_user .= "\n\n" . $comment->content;
		}

		if( @update_info ) {
			$comment_with_user .= "\n\n" . join("\n", @update_info);
		}

		$gi->comment($gh_issue->{number}, $comment_with_user);
	}

	# Set the current ticket status, if changed
	my $old_state = $gh_issue->{state};
	update_status( $gi, $gh_issue, $issue->status );
	if( $old_state ne $gh_issue->{state} ) {
		my $s = $issue->status;
		$gi->comment( $gh_issue->{number}, "Original ticket set status to $s (we converted to $gh_issue->{state})");
	}

	# TODO attachments?
}

sub update_status
{
	my ($gi, $gh, $gcode_status) = @_;
	if( grep { $_ eq $gcode_status } @gcode_closed_statii ) {
		$gi->close( $gh->{number} ) unless $gh->{state} eq 'closed';
		$gh->{state} = 'closed';
	} else {
		$gi->reopen( $gh->{number} ) unless $gh->{state} eq 'open';
		$gh->{state} = 'open';
	}
}

